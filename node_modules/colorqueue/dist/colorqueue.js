"use strict";
var penner = require('pennerts');
var ColorQueue = (function () {
    function ColorQueue(ledStrip, ledInterval) {
        if (ledInterval === void 0) { ledInterval = 100; }
        this.colorTransitionIndex = 0;
        this.colorTransitions = [];
        this.defaultTransitionFunction = penner.linear;
        this.lastColor = {
            r: 0,
            g: 0,
            b: 0,
            a: 0
        };
        this.ledStrip = ledStrip;
        this.ledInterval = ledInterval;
    }
    ColorQueue.prototype.set = function (colors) {
        this.colorTransitions = colors;
    };
    ColorQueue.prototype.add = function (color) {
        this.colorTransitions.push(color);
    };
    ColorQueue.prototype.remove = function (id) {
        var index = -1;
        this.colorTransitions.some(function (colorTransition, i) {
            if (colorTransition.order === id) {
                index = i;
                return true;
            }
        });
        if (index !== -1) {
            this.colorTransitions.splice(index, 1);
            if (this.colorTransitionIndex >= this.colorTransitions.length) {
                this.colorTransitionIndex = 0;
            }
        }
    };
    ColorQueue.prototype.clear = function () {
        this.colorTransitions.length = 0;
        this.colorTransitionIndex = 0;
        this.ledStrip.off();
    };
    ColorQueue.prototype.start = function () {
        var _this = this;
        this.lastStartTime = (new Date()).getTime();
        this.ledUpdaterTimerId = setInterval(function () { return _this.updateLeds(); }, this.ledInterval);
    };
    ColorQueue.prototype.stop = function () {
        clearInterval(this.ledUpdaterTimerId);
        this.ledStrip.off();
    };
    ColorQueue.prototype.updateLeds = function () {
        if (!Array.isArray(this.colorTransitions) || this.colorTransitions.length <= 0) {
            return;
        }
        var currentTime = (new Date()).getTime();
        var timeAfterStart = currentTime - this.lastStartTime;
        var currentColorTransition = this.colorTransitions[this.colorTransitionIndex];
        if (timeAfterStart > currentColorTransition.duration) {
            this.lastColor = currentColorTransition;
            this.lastStartTime = this.lastStartTime + currentColorTransition.duration;
            timeAfterStart = timeAfterStart - currentColorTransition.duration;
            this.colorTransitionIndex = (this.colorTransitionIndex + 1) % this.colorTransitions.length;
            currentColorTransition = this.colorTransitions[this.colorTransitionIndex];
            console.log("Switching to: colors[" + this.colorTransitionIndex + "]: " + JSON.stringify(currentColorTransition));
        }
        var transitionFunction = penner[currentColorTransition.transition] || this.defaultTransitionFunction;
        var r = Math.round(transitionFunction(timeAfterStart, this.lastColor.r, currentColorTransition.r - this.lastColor.r, currentColorTransition.duration));
        var g = Math.round(transitionFunction(timeAfterStart, this.lastColor.g, currentColorTransition.g - this.lastColor.g, currentColorTransition.duration));
        var b = Math.round(transitionFunction(timeAfterStart, this.lastColor.b, currentColorTransition.b - this.lastColor.b, currentColorTransition.duration));
        var a = transitionFunction(timeAfterStart, this.lastColor.a, currentColorTransition.a - this.lastColor.a, currentColorTransition.duration);
        // console.log(`timeAfterStart: ${timeAfterStart}`);
        // console.log(`lastColor: ${JSON.stringify(this.lastColor)}`);
        // console.log(`nextColor: ${JSON.stringify(currentColorTransition)}`);
        // console.log(`currentColor: ${JSON.stringify({ r, g, b, a })}`);
        this.ledStrip.all(r, g, b, a);
        this.ledStrip.sync();
    };
    return ColorQueue;
}());
exports.ColorQueue = ColorQueue;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ColorQueue;
//# sourceMappingURL=colorqueue.js.map